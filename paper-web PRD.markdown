# paper-web PRD



产品原型：https://www.figma.com/design/UUYsFPwTdoOaeaEfM15Lb3/paper_web?node-id=0-1&t=qJp2QApkHjxpfVau-1



### 项目背景

在科研的前期往往需要阅读大量文献，形成自己对于一个领域的基本认识，从而找出研究中的空白，立足自己的研究。本项目源自同门的科研需求，想要将自己从WoS等网站上下载的近百篇文献整理为表格，提取出其中的“数据源”、“研究方法”等近30个字段，从而定义研究空白，完成一篇系统性研究综述。

### 产品规划

#### 用户故事

作为一个研究人员，我想要了解某一研究问题的进展，在WoS上面根据摘要（Abstract）下载了该研究问题的近百篇的文献打算精读。在精读前，我希望进一步**比较和归类这些文献**，对研究方向有了更深的了解以后再精读。

![业务流程](./image/用户故事.png)

#### 业务流程

![业务流程](./image/流程图.png)

### 原型图

设计整体分为左右两栏。左栏提示操作，根据进度控制按钮状态；右栏在视口范围内根据左栏的点击情况展示对应的内容，其余内容隐藏。

![image](./image/原型思路.png)

### 功能逻辑

<table>
	<tr>
		<th>前端</th>
		<th>后端</th>
	<tr>
	<tr>
    <td colspan="2"><b>POST 传入参数</b></td>
	<tr>
  <tr>
		<td>1. API相关: <br>API类型（下拉选择）、<br>API主机（文本输入）、<br>API密钥（文本输入）</td>
		<td>1. 嵌入程序内部</td>
	<tr>
  <tr>
		<td>2. PDF文件</td>
		<td>2. 存入文件夹</td>
	<tr>
   <tr>
		<td>3. 待提取字段（文本输入）、<br>用于归类的字段（多选）</td>
		<td>3. 嵌入程序内部</td>
	<tr>
    <tr>
    <td colspan="2"><b>POST 触发运行</b></td>
	<tr>
  <tr>
		<td>1. 点击测试连接</td>
		<td>1. 运行测试连接相关程序，返回是否连接成功信息给前端</td>
	<tr>
  <tr>
		<td>2. 点击运行处理</td>
		<td>2. 运行运行处理相关程序相关程序，返回处理成功信息给前端</td>
	<tr>
  <tr>
		<td>3. 关闭或刷新网页</td>
		<td>3. 运行程序删除文献PDF和结果文件</td>
	<tr>
  <tr>
    <td colspan="2"><b>GET 获取参数</b></td>
	<tr>
  <tr>
		<td>1. 点击查看结果</td>
		<td>1. 将结果文件送给前端</td>
	<tr>
</table>

#### 1. 【前端】按钮状态变化

**按钮状态有三种：点击时或者悬浮时，一般状态，禁用时。**

- ==左栏的API、上传文件、添加字段按钮==有点击时或悬浮时，一般状态两种状态。
- ==左栏的运行处理、查看结果、下载表格按钮==有三种状态。处理逻辑如下：
  - 所有必要信息未全部输入时，“运行处理”、“查看结果”、“下载表格”按钮禁用；全部输入后，“运行处理”按钮处于一般状态。
  - 处理未完成时，“查看结果”和“下载表格”按钮禁用；处理完成后（可被理解为进度条至100%），“查看结果”、“下载表格”按钮处于一般状态。
  - 每次点击“运行处理”时，禁用“查看结果”和“下载表格”按钮。
- ==弹出框==关闭按钮只有一般状态。
- ==API弹出框==的测试按钮有点击时或悬浮时，一般状态两种状态。
- ==上传文件后文件列表==的删除按钮有点击时或悬浮时，一般状态两种状态。
- ==添加字段弹出框==的添加按钮只有一般状态。新字段输入有正在输入和输入完成两种状态。字段删除按钮只有一般状态。是否作为文献聚类字段的选中按钮有三种状态，逻辑如下。
  - 当输入的API类型为Moonshot时，禁用选中按钮。
  - 当输入的API类型为OpenAI时，有点击时或者悬浮时，一般状态两种。

#### 2. 【前端】右栏展示内容

|                | 何时展示                   | 何时关闭                             |
| -------------- | -------------------------- | ------------------------------------ |
| logo           | 1. 默认状态；2. 运行处理时 | 1. 展示文件列表时；2. 展示结果表格时 |
| API弹出框      | 点击API按钮                | 1. 点击其他左栏按钮；2. 关闭按钮     |
| 文件列表       | 上传文件后                 | 点击左栏其他按钮                     |
| 字段添加弹出框 | 点击添加字段按钮           | 1. 点击其他左栏按钮；2. 关闭按钮     |
| 进度条         | 运行处理时                 | 点击左栏其他按钮                     |
| 结果表格       | 点击查看结果按钮           | 点击左栏其他按钮                     |

- 进度条以每个文件30s的方式计算总时长运行。如果后端提前产生结果文件，则进度条提前结束，查看结果和下载表格按钮变为一般状态。如果后端落后产生结果文件，则进度条先结束，产生结果文件后查看结果和下载表格按钮变为一般状态。

#### 3. 【后端】从文献中提取字段

==**输入：**==如果之前有结果文件old_df，提取old_filenames, old_headers, 与新输入的文件名和字段作差集得到new_filenames, new_headers。如果之前没有结果文件，则将新输入的文件名和字段记为new_filenames, new_headers，old_filenames与old_headers记为空值。

==**逻辑：**==一定会有new_filenames和new_headers这两个变量：

1. 如果之前没有结果文件

   - new_filenames不为空，new_headers不为空

   - 对于每一个文件（in new_filenames）

     - 利用大模型进行提取new_headers

     - 输出：该文件的对应字段

   - 组成df

2. 如果之前有结果文件，只新增了pdf

   - new_filenames不为空，new_headers为空，old_df不为空，old_headers不为空
   - 对于每一个新增文件（in new_filenames）
     - 利用大模型进行提取old_headers，
     - 输出：该新增文件的对应字段
   - 合并old_df和df

3. 如果之前有结果文件，只新增了headers

   - new_filenames为空，new_headers不为空，old_df不为空，old_filenames不为空
   - 对于每一个旧文件（in old_filenames）
     - 利用大模型提取new_headers
     - 输出：旧文件的新字段
   - 更新old_df

4. 如果之前有文件，同时新增了pdf和headers

   - new_filenames不为空，new_headers不为空，old_df不为空，old_filenames不为空，old_headers不为空
   - 对于每一个新增文件（in new_filenames）
     - 利用大模型提取headers（new_headers+old_headers）
     - 输出：该新增文件的对应字段
   - 对于每一个旧文件（in old_filenames）
     - 利用大模型提取new_headers
     - 输出：旧文件的新字段

   - 合并old_df和df

5. 如果之前有文件，但都没有新增（new_filenames为空，new_headers为空）

   - 不运行，提示未增加新内容

==**输出：**==将df保存在result文件夹中，形成xlsx格式的结果文件

补充：为了避免引发大模型的速率限制，目前每处理一个文件都要等待5s再处理下一个文件。

#### 4. 【后端】根据字段进行归类

==**输入：**==选中的用于归类的字段。（考虑到目前项目的情况，当选择OpenAI类型的API时，字段可以被选择是否用于归类。）

==**逻辑：**== 没有结果文件时，用户填入用于归类的字段则需要聚类，反之则不需要。已有结果文件时，用户填入的聚类字段更新时需要聚类，反之则不需要。

Step1: 文字转向量

1. 把每篇文献用于聚类的大模型提取出来的字段合并成一个字符串，形成名为'text'的一列；
2. 调用embedding模型（当前为text-embedding-3-small）生成这些字符串的向量，形成名为'text_embedding'的一列；

Step2: kMeans聚类

3. 找到kMeans聚类分数最高的一个聚类数k；
4. 将文献聚为k类，分类结果为kMeans预测的结果，形成一列，列名为“Cluster+聚类时所用的字段”
5. 将同类文献的聚类字段组成一个长字符串，让大模型总结同类文献的共性，形成一列，列名为“Topic+聚类时所用的字段”
6. 删除"text"和“text_embedding”列

==**输出：**==Cluster和Topic两列



### 上线后的评价指标

访问次数、处理的文件数、常用字段。

（目前这一部分的数据埋点还未开发）



### 致谢

感谢在 极狐GitLab/驭码CodeRider 的实习经历对本项目的指导，感谢同门Zylox提出项目需求，感谢Baojing对项目设计部分的贡献。

感谢Chatbox在API弹出框方面的设计参考，感谢OpenAI-App（BY DhunganaKB）项目参考。





